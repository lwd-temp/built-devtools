{"version":3,"file":"RendererHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/RendererHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData, type FrameProcessData} from './MetaHandler.js';\nimport {data as samplesHandlerData} from './SamplesHandler.js';\nimport {HandlerState, type TraceEventHandlerName} from './types.js';\n\n/**\n * This handler builds the hierarchy of trace events and profile calls\n * on each thread on each process.\n *\n * Throughout the code, trace events and profile calls are referred to\n * as \"entries\", but note they are different types of data. Trace events\n * come directly from the backend and it's the type the engine commonly\n * refers to. Profile calls on the other hand are built in the frontend,\n * and, for compatibility purposes, typed as an extension to the trace\n * event type.\n */\n\nconst processes = new Map<Types.TraceEvents.ProcessID, RendererProcess>();\n\n// We track the compositor tile worker thread name events so that at the end we\n// can return these keyed by the process ID. These are used in the frontend to\n// show the user the rasterization thread(s) on the main frame as tracks.\nconst compositorTileWorkers = Array<{\n  pid: Types.TraceEvents.ProcessID,\n  tid: Types.TraceEvents.ThreadID,\n}>();\nconst entryToNode = new Map<Types.TraceEvents.RendererEntry, RendererEntryNode>();\nconst allRendererEvents: Types.TraceEvents.TraceEventRendererEvent[] = [];\nlet nodeIdCount = 0;\nconst makeRendererEntrytNodeId = (): RendererEntryNodeId => (++nodeIdCount) as RendererEntryNodeId;\nconst completeEventStack: (Types.TraceEvents.TraceEventSyntheticCompleteEvent)[] = [];\n\nlet handlerState = HandlerState.UNINITIALIZED;\nlet config: Types.Configuration.Configuration = Types.Configuration.DEFAULT;\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  entries: [],\n});\n\nconst makeEmptyRendererTree = (): RendererTree => ({\n  nodes: new Map(),\n  roots: new Set(),\n  maxDepth: 0,\n});\n\nconst makeEmptyRendererEventNode =\n    (entry: Types.TraceEvents.RendererEntry, id: RendererEntryNodeId): RendererEntryNode => ({\n      entry,\n      id,\n      parentId: null,\n      children: new Set(),\n      depth: 0,\n    });\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, pid: Types.TraceEvents.ProcessID):\n        RendererProcess => {\n          return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n        };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.TraceEvents.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  config = userConfig;\n}\n\nexport function reset(): void {\n  processes.clear();\n  entryToNode.clear();\n  allRendererEvents.length = 0;\n  completeEventStack.length = 0;\n  compositorTileWorkers.length = 0;\n  nodeIdCount = -1;\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Renderer Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Renderer Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name?.startsWith('CompositorTileWorker')) {\n    compositorTileWorkers.push({\n      pid: event.pid,\n      tid: event.tid,\n    });\n  }\n\n  if (Types.TraceEvents.isTraceEventBegin(event) || Types.TraceEvents.isTraceEventEnd(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    const completeEvent = makeCompleteEvent(event);\n    if (!completeEvent) {\n      return;\n    }\n    thread.entries.push(completeEvent);\n    allRendererEvents.push(completeEvent);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventInstant(event) || Types.TraceEvents.isTraceEventComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.entries.push(event);\n    allRendererEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Renderer Handler is not initialized');\n  }\n\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes);\n  sanitizeThreads(processes);\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): RendererHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Renderer Handler is not finalized');\n  }\n\n  return {\n    processes: new Map(processes),\n    compositorTileWorkers: new Map(gatherCompositorThreads()),\n    entryToNode: new Map(entryToNode),\n    allRendererEvents: [...allRendererEvents],\n  };\n}\n\nfunction gatherCompositorThreads(): Map<Types.TraceEvents.ProcessID, Types.TraceEvents.ThreadID[]> {\n  const threadsByProcess = new Map<Types.TraceEvents.ProcessID, Types.TraceEvents.ThreadID[]>();\n  for (const worker of compositorTileWorkers) {\n    const byProcess = threadsByProcess.get(worker.pid) || [];\n    byProcess.push(worker.tid);\n    threadsByProcess.set(worker.pid, byProcess);\n  }\n  return threadsByProcess;\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess:\n        Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>):\n    void {\n  assignOrigin(processes, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, rendererProcessesByFrame, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData): void {\n  for (const renderProcessesByPid of rendererProcessesByFrame.values()) {\n    for (const [pid, processWindows] of renderProcessesByPid) {\n      for (const processInfo of processWindows.flat()) {\n        const process = getOrCreateRendererProcess(processes, pid);\n        // Sometimes a single process is responsible with rendering multiple\n        // frames at the same time. For example, see https://crbug.com/1334563.\n        // When this happens, we'd still like to assign a single url per process\n        // so: 1) use the first frame rendered by this process as the url source\n        // and 2) if the last url is \"about:blank\", use the next frame's url,\n        // data from about:blank is irrelevant.\n        if (process.url === null || process.url === 'about:blank') {\n          // If we are here, it's because we care about this process and the URL. But before we store\n          // it, we check if it is a valid URL by trying to create a URL object. If it isn't, we won't\n          // set it, and this process will be filtered out later.\n          try {\n            new URL(processInfo.frame.url);\n            process.url = processInfo.frame.url;\n          } catch (e) {\n            process.url = null;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData): void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess:\n        Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>):\n    void {\n  for (const [, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n        const thread = getOrCreateRendererThread(process, tid);\n        thread.name = threadInfo?.args.name ?? `${tid}`;\n      }\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unkonwn origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.TraceEvents.ProcessID, RendererProcess>): void {\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    if (process.url === null) {\n      processes.delete(pid);\n      continue;\n    }\n    const asUrl = new URL(process.url);\n    if (asUrl.protocol === 'about:') {\n      processes.delete(pid);\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.TraceEvents.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>,\n    options?: {filter: {has: (name: Types.TraceEvents.KnownEventName) => boolean}}): void {\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      if (!thread.entries.length) {\n        thread.tree = makeEmptyRendererTree();\n        continue;\n      }\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.entries);\n      // Step 2. Inject profile calls from samples\n      const cpuProfile = samplesHandlerData().profilesInProcess.get(pid)?.get(tid)?.parsedProfile;\n      const samplesIntegrator =\n          cpuProfile && new Helpers.SamplesIntegrator.SamplesIntegrator(cpuProfile, pid, tid, config);\n      const profileCalls = samplesIntegrator?.buildProfileCalls(thread.entries);\n      if (profileCalls) {\n        thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, profileCalls);\n      }\n      // Step 3. Build the tree.\n      thread.tree = treify(thread.entries, options);\n    }\n  }\n}\n\n/**\n * Builds a hierarchy of the entries (trace events and profile calls) in\n * a particular thread of a particular process, assuming that they're\n * sorted, by iterating through all of the events in order.\n *\n * The approach is analogous to how a parser would be implemented. A\n * stack maintains local context. A scanner peeks and pops from the data\n * stream. Various \"tokens\" (events) are treated as \"whitespace\"\n * (ignored).\n *\n * The tree starts out empty and is populated as the hierarchy is built.\n * The nodes are also assumed to be created empty, with no known parent\n * or children.\n *\n * Complexity: O(n), where n = number of events\n */\nexport function treify(\n    entries: Types.TraceEvents.RendererEntry[],\n    options?: {filter: {has: (name: Types.TraceEvents.KnownEventName) => boolean}}): RendererTree {\n  const stack = [];\n  // Reset the node id counter for every new renderer.\n  nodeIdCount = -1;\n  const tree = makeEmptyRendererTree();\n  for (let i = 0; i < entries.length; i++) {\n    const event = entries[i];\n    // If the current event should not be part of the tree, then simply proceed\n    // with the next event.\n    if (options && !options.filter.has(event.name as Types.TraceEvents.KnownEventName)) {\n      continue;\n    }\n\n    const duration = event.dur || 0;\n    const nodeId = makeRendererEntrytNodeId();\n    const node = makeEmptyRendererEventNode(event, nodeId);\n\n    // If the parent stack is empty, then the current event is a root. Create a\n    // node for it, mark it as a root, then proceed with the next event.\n    if (stack.length === 0) {\n      tree.nodes.set(nodeId, node);\n      tree.roots.add(node);\n      event.selfTime = Types.Timing.MicroSeconds(duration);\n      stack.push(node);\n      tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n      entryToNode.set(event, node);\n      continue;\n    }\n\n    const parentNode = stack.at(-1);\n    if (parentNode === undefined) {\n      throw new Error('Impossible: no parent node found in the stack');\n    }\n\n    const parentEvent = parentNode.entry;\n\n    const begin = event.ts;\n    const parentBegin = parentEvent.ts;\n    const parentDuration = parentEvent.dur || 0;\n    const end = begin + duration;\n    const parentEnd = parentBegin + parentDuration;\n    // Check the relationship between the parent event at the top of the stack,\n    // and the current event being processed. There are only 4 distinct\n    // possiblities, only 2 of them actually valid, given the assumed sorting:\n    // 1. Current event starts before the parent event, ends whenever. (invalid)\n    // 2. Current event starts after the parent event, ends whenever. (valid)\n    // 3. Current event starts during the parent event, ends after. (invalid)\n    // 4. Current event starts and ends during the parent event. (valid)\n\n    // 1. If the current event starts before the parent event, then the data is\n    //    not sorted properly, messed up some way, or this logic is incomplete.\n    const startsBeforeParent = begin < parentBegin;\n    if (startsBeforeParent) {\n      throw new Error('Impossible: current event starts before the parent event');\n    }\n\n    // 2. If the current event starts after the parent event, then it's a new\n    //    parent. Pop, then handle current event again.\n    const startsAfterParent = begin >= parentEnd;\n    if (startsAfterParent) {\n      stack.pop();\n      i--;\n      // The last created node has been discarded, so discard this id.\n      nodeIdCount--;\n      continue;\n    }\n    // 3. If the current event starts during the parent event, but ends\n    //    after it, then the data is messed up some way, for example a\n    //    profile call was sampled too late after its start, ignore the\n    //    problematic event.\n    const endsAfterParent = end > parentEnd;\n    if (endsAfterParent) {\n      continue;\n    }\n\n    // 4. The only remaining case is the common case, where the current event is\n    //    contained within the parent event. Create a node for the current\n    //    event, establish the parent/child relationship, then proceed with the\n    //    next event.\n    tree.nodes.set(nodeId, node);\n    node.depth = stack.length;\n    node.parentId = parentNode.id;\n    parentNode.children.add(node);\n    event.selfTime = Types.Timing.MicroSeconds(duration);\n    if (parentEvent.selfTime !== undefined) {\n      parentEvent.selfTime = Types.Timing.MicroSeconds(parentEvent.selfTime - (event.dur || 0));\n    }\n    stack.push(node);\n    tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n    entryToNode.set(event, node);\n  }\n  return tree;\n}\n\nexport function makeCompleteEvent(event: Types.TraceEvents.TraceEventBegin|Types.TraceEvents.TraceEventEnd):\n    Types.TraceEvents.TraceEventSyntheticCompleteEvent|null {\n  if (Types.TraceEvents.isTraceEventEnd(event)) {\n    // Quietly ignore unbalanced close events, they're legit (we could\n    // have missed start one).\n    const beginEvent = completeEventStack.pop();\n    if (!beginEvent) {\n      return null;\n    }\n    if (beginEvent.name !== event.name || beginEvent.cat !== event.cat) {\n      console.error(\n          'Begin/End events mismatch at ' + beginEvent.ts + ' (' + beginEvent.name + ') vs. ' + event.ts + ' (' +\n          event.name + ')');\n      return null;\n    }\n    // Update the begin event's duration using the timestamp of the end\n    // event.\n    beginEvent.dur = Types.Timing.MicroSeconds(event.ts - beginEvent.ts);\n    return null;\n  }\n\n  // Create a synthetic event using the begin event, when we find the\n  // matching end event later we will update its duration.\n  const syntheticComplete: Types.TraceEvents.TraceEventSyntheticCompleteEvent = {\n    ...event,\n    ph: Types.TraceEvents.Phase.COMPLETE,\n    dur: Types.Timing.MicroSeconds(0),\n  };\n\n  completeEventStack.push(syntheticComplete);\n  return syntheticComplete;\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta', 'Samples'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.TraceEvents.ProcessID, RendererProcess>;\n  /**\n   * A map of all compositor workers (which we show in the UI as Rasterizers)\n   * by the process ID.\n   */\n  compositorTileWorkers: Map<Types.TraceEvents.ProcessID, Types.TraceEvents.ThreadID[]>;\n  entryToNode: Map<Types.TraceEvents.RendererEntry, RendererEntryNode>;\n  /**\n   * All trace events and synthetic profile calls made from\n   * samples.\n   */\n  allRendererEvents: Types.TraceEvents.TraceEventRendererEvent[];\n}\n\nexport interface RendererProcess {\n  // In an ideal world this would be modelled as a URL, but URLs cannot be sent\n  // between the main thread and workers, so we have to store it as a string.\n  url: string|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.TraceEvents.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  /**\n   * Contains trace events and synthetic profile calls made from\n   * samples.\n   */\n  entries: Types.TraceEvents.RendererEntry[];\n  tree?: RendererTree;\n}\n\nexport interface RendererTree {\n  nodes: Map<RendererEntryNodeId, RendererEntryNode>;\n  roots: Set<RendererEntryNode>;\n  maxDepth: number;\n}\n\nexport interface RendererEntryNode {\n  entry: Types.TraceEvents.RendererEntry;\n  depth: number;\n  id: RendererEntryNodeId;\n  parentId?: RendererEntryNodeId|null;\n  children: Set<RendererEntryNode>;\n}\n\nclass RendererEventNodeIdTag {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #tag: (symbol|undefined);\n}\nexport type RendererEntryNodeId = number&RendererEventNodeIdTag;\n"]}