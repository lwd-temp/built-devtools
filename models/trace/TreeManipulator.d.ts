import type * as Handlers from './handlers/handlers.js';
import type * as Types from './types/types.js';
type EntryToNodeMap = Map<Types.TraceEvents.RendererEntry, Handlers.ModelHandlers.Renderer.RendererEntryNode>;
export interface UserTreeAction {
    type: 'MERGE_FUNCTION' | 'COLLAPSE_FUNCTION';
    entry: Types.TraceEvents.RendererEntry;
}
/**
 * This class can take in a thread that has been generated by the
 * RendererHandler and apply certain actions to it in order to modify what is
 * shown to the user. These actions can be automatically applied by DevTools or
 * applied by the user.
 *
 * Once actions are applied, the visibleEntries() method will return only the
 * entries that are still visible, and this is the list of entries that can
 * then be used to render the resulting thread on the timeline.
 **/
export declare class TreeManipulator {
    #private;
    constructor(thread: Handlers.ModelHandlers.Renderer.RendererThread, entryToNode: EntryToNodeMap);
    /**
     * Applies an action to the visible tree. This will also clear the cache of
     * visible entries, ensuring that it will be recalculated with the latest set
     * of actions.
     **/
    applyAction(action: UserTreeAction): void;
    /**
     * Removes a matching action, if one is found, from the active actions set.
     * Note that we do not match on action equality and instead search through
     * the set of active actions for one that is of the same type, and has the
     * same entry associated with it.
     *
     * This is a no-op if the action is not active.
     **/
    removeActiveAction(action: UserTreeAction): void;
    /**
     * The set of entries that are visible given the set of applied actions. If
     * no actions are applied, this will return all entries in the thread.
     *
     * This method is cached, so it is safe to call multiple times.
     **/
    visibleEntries(): readonly Types.TraceEvents.TraceEventData[];
}
export {};
