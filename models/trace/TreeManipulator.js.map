{"version":3,"file":"TreeManipulator.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/TreeManipulator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\n\nimport type * as Handlers from './handlers/handlers.js';\nimport type * as Types from './types/types.js';\n\ntype EntryToNodeMap = Map<Types.TraceEvents.RendererEntry, Handlers.ModelHandlers.Renderer.RendererEntryNode>;\n\nexport interface UserTreeAction {\n  type: 'MERGE_FUNCTION'|'COLLAPSE_FUNCTION';\n  entry: Types.TraceEvents.RendererEntry;\n}\n\n/**\n * This class can take in a thread that has been generated by the\n * RendererHandler and apply certain actions to it in order to modify what is\n * shown to the user. These actions can be automatically applied by DevTools or\n * applied by the user.\n *\n * Once actions are applied, the visibleEntries() method will return only the\n * entries that are still visible, and this is the list of entries that can\n * then be used to render the resulting thread on the timeline.\n **/\nexport class TreeManipulator {\n  readonly #thread: Handlers.ModelHandlers.Renderer.RendererThread;\n  // Maps from an individual TraceEvent entry to its representation as a\n  // RendererEntryNode. We need this so we can then parse the tree structure\n  // generated by the RendererHandler.\n  #entryToNode: EntryToNodeMap;\n\n  // Track the last calculated set of visible entries. This means we can avoid\n  // re-generating this if the set of actions that have been applied has not\n  // changed.\n  #lastVisibleEntries: readonly Types.TraceEvents.RendererEntry[]|null = null;\n  #activeActions: UserTreeAction[] = [];\n\n  constructor(\n      thread: Handlers.ModelHandlers.Renderer.RendererThread,\n      entryToNode: EntryToNodeMap,\n  ) {\n    this.#thread = thread;\n    this.#entryToNode = entryToNode;\n  }\n\n  /**\n   * Applies an action to the visible tree. This will also clear the cache of\n   * visible entries, ensuring that it will be recalculated with the latest set\n   * of actions.\n   **/\n  applyAction(action: UserTreeAction): void {\n    if (this.#actionIsActive(action)) {\n      // If the action is already active there is no reason to apply it again.\n      return;\n    }\n\n    this.#activeActions.push(action);\n    // Clear the last list of visible entries - this invalidates the cache and\n    // ensures that the visible list will be recalculated, which we have to do\n    // now we have changed the list of actions.\n    this.#lastVisibleEntries = null;\n  }\n\n  /**\n   * Removes a matching action, if one is found, from the active actions set.\n   * Note that we do not match on action equality and instead search through\n   * the set of active actions for one that is of the same type, and has the\n   * same entry associated with it.\n   *\n   * This is a no-op if the action is not active.\n   **/\n  removeActiveAction(action: UserTreeAction): void {\n    let removedAction = false;\n    this.#activeActions = this.#activeActions.filter(activeAction => {\n      if (activeAction.type === action.type && activeAction.entry === action.entry) {\n        removedAction = true;\n        return false;\n      }\n      return true;\n    });\n\n    if (removedAction) {\n      // If we found and removed an action, we need to clear the cache to force\n      // the set of visible entries to be recalculcated.\n      this.#lastVisibleEntries = null;\n    }\n  }\n\n  #actionIsActive(action: UserTreeAction): boolean {\n    return this.#activeActions.some(activeAction => {\n      return action.entry === activeAction.entry && action.type === activeAction.type;\n    });\n  }\n\n  /**\n   * The set of entries that are visible given the set of applied actions. If\n   * no actions are applied, this will return all entries in the thread.\n   *\n   * This method is cached, so it is safe to call multiple times.\n   **/\n  visibleEntries(): readonly Types.TraceEvents.TraceEventData[] {\n    if (this.#activeActions.length === 0) {\n      return this.#thread.entries;\n    }\n    return this.#calculateVisibleEntries();\n  }\n\n  #calculateVisibleEntries(): readonly Types.TraceEvents.TraceEventData[] {\n    // When an action is added, we clear this cache. So if this cache is\n    // present it means that the set of active actions has not changed, and so\n    // we do not need to recalculate anything.\n    if (this.#lastVisibleEntries) {\n      return this.#lastVisibleEntries;\n    }\n\n    if (!this.#thread.tree) {\n      // We need a tree to be able to calculate user actions, if we do not have\n      // it, just return all the entries.\n      return this.#thread.entries;\n    }\n\n    // We apply each user action in turn to the set of all entries, and mark\n    // any that should be hidden by adding them to this set. We do this to\n    // ensure we minimise the amount of passes through the list of all entries.\n    // Another approach would be to use splice() to remove items from the\n    // array, but doing this would be a mutation of the arry for every hidden\n    // event. Instead, we add entries to this set, and at the very end loop\n    // through the entries array once to filter out any that should be hidden.\n    const entriesToHide = new Set<Types.TraceEvents.RendererEntry>();\n\n    const entries = [...this.#thread.entries];\n    for (const action of this.#activeActions) {\n      switch (action.type) {\n        case 'MERGE_FUNCTION': {\n          // The entry that was clicked on is merged into its parent. All its\n          // children remain visible, so we just have to hide the entry that was\n          // selected.\n          entriesToHide.add(action.entry);\n          break;\n        }\n\n        case 'COLLAPSE_FUNCTION': {\n          // The entry itself remains visible, but all of its ancestors are hidden.\n          const entryNode = this.#entryToNode.get(action.entry);\n          if (!entryNode) {\n            // Invalid node was given, just ignore and move on.\n            continue;\n          }\n          const allAncestors = this.#findAllAncestorsOfNode(entryNode);\n          allAncestors.forEach(ancestor => entriesToHide.add(ancestor));\n          break;\n        }\n        default:\n          Platform.assertNever(action.type, `Unknown TreeManipulator action: ${action.type}`);\n      }\n    }\n\n    // Now we have applied all actions, loop through the list of entries and\n    // remove any that are marked as hidden.\n    // We cache this under lastVisibleEntries - if this function is called\n    // again and the user actions have not changed, we can avoid recalculating\n    // this and just return the last one. This cache is automatically cleared\n    // when the user actions are changed.\n    this.#lastVisibleEntries = entries.filter(entry => {\n      return entriesToHide.has(entry) === false;\n    });\n\n    return this.#lastVisibleEntries;\n  }\n\n  #findAllAncestorsOfNode(\n      root: Handlers.ModelHandlers.Renderer.RendererEntryNode): Types.TraceEvents.RendererEntry[] {\n    const ancestors: Types.TraceEvents.RendererEntry[] = [];\n\n    // Walk through all the ancestors, starting at the root node.\n    const children: Handlers.ModelHandlers.Renderer.RendererEntryNode[] = Array.from(root.children);\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        ancestors.push(childNode.entry);\n        const newChildIds = Array.from(childNode.children);\n        children.push(...newChildIds);\n      }\n    }\n\n    return ancestors;\n  }\n}\n"]}